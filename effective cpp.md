1:关于虚析构，因为暂时只看到item5，暂时只写这一部分，即，如果这个类的父类声明的析构函数是虚拟的，则子类的default的析构函数也是虚拟的，这个虚拟性来自于父类。虚析构的用法，首先我们需要明白为什么需要虚析构，假设我们使用一个工厂模式去提供子类对象给用户，这个时候如果用户有析构的需求，那么他的调用方式大概率是通过一个父类指针指向我们工厂模式提供的对象。这个时候就造成了我们很有可能只析构了父类，而没有析构子类成分的情况，这也会造成一定程度上的内存泄漏。对应的解决方案就是采用虚析构函数。如果采用虚析构函数，那么就实现了虚析构函数的多态调用（父类指针指向子类对象并调用虚函数。）;这个时候，就会达到我们想要的，父类对象，子类对象全部析构的效果。看到这里，我们很明显可以发现，这个和QT的父子链的效果完全一致。我们可以使用这个方式，来实现QT父子链父类析构时析构其所有子类对象的效果。  

2:如果我们需要屏蔽编译器默认生成的函数，即构造函数，拷贝构造函数和赋值重载函数等，我们可以使用的方法是创建一个baseClass并将对应的方法显示声明为private，这样继承下去的也会是private即不可被外部访问（友元不受此限制）。但是C11之后有一种更为优雅的方式，即=delete。用法很简单。那么我们来探讨一下稍微深入的一个问题，即我一开始认为有没有一种可能，=delete也是采用声明为private的方式来实现的。这个问题可以用友元来验证，如果=delete声明之后使用友元，友元能够访问到对应的函数，那么就有可能，或者大概率是这么实现的。如果友元依然不能够访问，那么说明=delete的优势在于封装的更好，并且两种可能（1：使用此方法实现并做特殊处理，2：使用全新的另一种方式实现）。

3:如果class不含virtual函数，表明它大概率不会被用作base class,在这种情况下，令其析构函数为virtual是个馊主意，只有当一个class中有virtual函数，才将其析构函数声明为virtual。总体来说，这几条都是为了避免一点，析构函数的多态不生效。同样，我们在使用多态时，就应该考虑，我们的多态是否会导致其子类按照我们的需求也进行析构。 

4:关于条款12拷贝构造函数中应复制所有成分，包括成员变量和父类继承下来的元素，其中在拷贝构造函数中调用了父类的的拷贝构造函数，传入了子类的拷贝构造函数的参数（引用）。我一开始的疑惑是，明明是父类之间的拷贝，又没有返回值承接，是如何把父类的这个状态继承到子类的？但是这个疑问在看了父类的拷贝构造之后就不应该存在了，父类的拷贝构造函数中最终的结果是返回一个this指针，也就是说，当前者这个情况，子类在构造之前父类对象早就被构造出来了，即使是在子类拷贝构造函数中调用，最终的修改也会保存到子类对应的父类对象中（this指针）。

5:以独立的newed对象置入智能指针，processWidget(std::tr1::shared_ptr\<Widget\>(new Widget),priority());这种调用方法在特定次序下：1，new Widget, 2, priority() 3,构造share_ptr时有可能造成资源泄露，即new了widget但是不一定有负责调用析构的对象(2失败导致3未构造)     。

6:从通常的印象来说，private,protected,public应该是三种不同的权限访问控制级别，因此我们可能会“合理地”认为这也是三种不同的封装控制级别，但事实上，封装性只有两种级别，private和其他，private限制仅在类的对象中能访问。至于public和protected，一个例子可以很好的证明，如果一个成员变量是protected，假设你删除了这个成员变量，那么影响的代码会包含此类以及子类的对象，这已经是一笔巨大的开销，public无非是导致了更大的开销，但相对于private而言，这两者的区别无非是1W和10W的区别，相比于10，都是不能接受的。

7:宁愿使用non-member函数替换menber函数以及friend，这一条款的核心问题就是，根据例子中的web操作，清除cookies以及其他的清除函数，如果想完成一个统一的清除操作，这时候我们是有两种选择的，1是直接做一个新的成员函数调用上述的成员函数（这种方法非常常见，甚至我之前写的代码大多数也是这么去实现的，因为写法很简单）。2则分了两种情况，对于java这种习惯于所有函数定义在类中的程序猿（其实之前我任职的公司大多数也差不多，很少会涉及到类之外的）可以采用创建广工具类(utility class)并编写对应的static member函数来实现，无非是需要有一个实例化对象（但这是必要的），对于CPP则有一种更为优雅的方式，即将对应的操作函数封装到一个namespace中，此时想想前公司应该是两种方法都采用了，实现了较多的选择。对比而言，1确实更容易成为我们的选择，原因之一就是我们很多时候写的类并不会作为一个通用性特别强的类，因此单独再写一个namespace或者class，实属没必要，但是对于一些通用性比较强的，必要的，比如前公司的底层SDK，关于数据库的操作等，经常会有2的这种方案，这块比较需要的地方在于构思整个代码或者APP框架的时候，以及会涉及到二次开发编写底层SDK的时候来使用。

插播一条广告：
***
# 类模板
## 模板的具体化
1. 隐式实例化,implicit instantiation,
```
ArraytTP <double,30> * pt;
pt = new ArrayTP<double ,30>;
```
2. 显式实例化,
```
template class ArrayTP<string,100>;
```
3. 显式具体化，explicit specialization
显示具体化的目的是处理一些特殊情况，比如>这个符号对于const char *比较是不生效的，必须通过strcmp来进行比较，这时候通用的模板对于这个特殊的类型就需要具体化了。即根据一个规则-当具体化模板和通用模板都与实例化请求匹配时，编译器将使用具体化版本。
```
template <> class ClassName<specialized-type-name>  //通用格式
tempate <> class SortedArray<const char char*>
{
    ...
};
```
4. 部分具体化，说起来高大上，其实只是给模板的参数列表中的一个指定类型
```
// general template
template <class T1,class T2> class Pair {...};
// specialization with T2 set to int
template<class T1> class Pair<T1,int>{...}; //从这儿也可以得到一个结论，有多少未具体化的参数，template<>括号内就有多少参数，外面则是具体化了的参数
```
模板具体化匹配时会选择具体化最高的版本
## 模板类和友元函数
分为三类：非模板友元，约束模板友元，非约束模板友元。三个类型用我自己的话来说，第一个非模板友元，这个举例的时候是用的非模板友元函数，但是拿模板做参数来讲解的，因此这个需要对模板参数进行一个具体化。第二个约束模板函数和非约束模板函数的区别有点像类中的this的定义，
### 非模板友元函数
实际上调用的时候没区别，比如书上的report，也是正常调用，有声明上的差距和实现上的差距：
声明是如下：
```
friend void report(HasFriend<T> &); //不能用HasFriend&，因为没有这个具体化，只有HasFriend<int>这种  前面也不会是void report<>();因为这个地方考虑的是非模板
```
一般支持模板类的实现是如下
```
void report(ClassName <T>)
{
    T.....;
}
```
但是我们可以使用一些类似于重载的方法去使之进行一些特化，比如
```
void report(ClassName <int>)
{

}
void report(ClassName <double>)
{
}
```
### 约束模板友元
目的是使类的每一个具体化都获得与友元匹配的具体化。需要三步：
1. 类定义的前面声明每个模板函数
```
template <typename T> void counts();
template <typename T>void report(T &);
```
2. 在类的成员列表中进行模板友元的声明
```
template <typename TT>
class HasFriendT
{
    friend void counts<TT>();
    friend void report<TT>(HasFriendT <TT> &);  //前面report<TT>中的TT可以省略但尖括号不能
}
```
关于这个的理解我们去考虑一个问题，模板类最后实例化的时候必定会有一个具体的对象，比如HasFriend\<int\>，那么在类声明中所有出现的TT都会被换成int,假设counts的声明中不出现TT，那么我们也无法确定这个模板匹配的类型到底是不是int，同理后面report也一致，但因report可以通过参数列表来具体化，因此有一个TT可以被省略，但counts不能。
最终产生的结果是counts\<double\>和counts\<int\>的大小会独立计算，也就是属于每一个具体化本身
### 非约束模板友元函数
```
template <typename T>
class ManyFriend
{
    ...
public:
    template <typename C,typename D> friend void show2(C &, D &);
}
```
这个地方没怎么细讲，但是我们可以考虑一个问题，即非模板友元函数中讲的，为什么不能是HasFriend& 而这里可以是C&和D&。因为C和D都代表一个具体的类型，ManyFriend\<int\>或者其他什么。<br>
插播结束
***
8. **考虑写一个不抛出异常的swap对实际编码的意义？目前对我来说仅仅是让我重温了一下模板，但并没有明白为什么作者需要告诉我这一条。**，看了总结之后多少明白了，这点是在当你需要对你自己的类型，比如类，或者什么其他东西进行一个swap，那么这时候std的或者已有的swap基本都不满足你的要求，这时候简单的方案多数时候就是类里给个成员函数去做这件事，但是按照这一条，我们还需要编写一个非成员函数来调用这个。这一切都需要确认一点：目的是写一个通用性swap，无论以何种方式的通用，因为如果只是简单的一个类的swap，固定对象，没必要做这么复杂，这一条的讨论都是针对于模板swap来讲的。
9. 尽可能延后定义式出现的时间，这个其实是比较常见的一个点了，比如我们写一个接口的时候，类的构造和变量的构造，都尽量放在各种会return的判断之后，尽量避免构造了却不使用的情况。for循环那个也比较正常，大数量定义在外，小数量在里。基础玩意。
10. 关于转型，常规的转型，或者说转换，基本都是隐式转换或类似于(T)的显式转换，但是实际使用中其实也会使用到static_cast以及dynmic_cast，其他两种转型用的比较少，总体来讲，转型这块的重点需要记得dynmic转型会比较消耗时间，尽量避免。
11. 避免返回handles指向对象内部，包括引用，指针，迭代器，这个地方书上的第一个例子在需要返回引用的情况下使用const修饰，第二个例子则比较有趣，在我们使用const之后，我们从一定程度上确保了不会被修改，但依然无法避免空指针的情况。实际中这种因为提前复制了一个指针但是对应的对象析构导致内部数据析构形成空指针的情况比较常见。这个目前我认为如果作为上层使用者，只有完整的开发规范-使用前进行指针的判断，能够尽量避免。作为SDK开发者的话，应该没有过多的办法。
12. 关于异常抛出，一个合格的异常安全函数应该做到：1.不泄露任何资源。2.不允许数据败坏。异常安全函数提供以下三个级别的保护： <br>
<table>
<tr>
<th>基本承诺</th><th>当异常抛出时，程序的事物保持有效状态，没有数据败坏，但程序实现状态无法预料，即无法知道执行到那一步了。</th>
</tr>
<tr>
<th>强烈保证</th><th>简单来说，具有事务性，失败则回退到调用前的状态</th>
</tr>
<tr>
<th>不抛掷保证</th><th>不抛出异常，总是能够完成原先功能，作用于内置类型的所有操作都提供了nothrow保证， int doSomeThing()throw{}这个例子一旦抛出异常，即是严重错误。</th>
</tr>
</table>
在理想状态下，我们其实都希望代码具有强烈保证，但是强烈保证的实现是非常困难的。可行的方案有一种-假如我们有一个函数完全不会访问外部的数据，仅从其参数列表访问外部数据，那么我们可以对参数列表进行一个复制，所有的操作都先对复制进行，在确认成功，流程走通之后将修改实际生效到原对象。即数据库的事务性实现思路。但我们可以想到，首先是参数列表复制的开销，其次是仅从参数列表获取外部数据的函数在实际代码中几乎不会出现，例如成员函数大概率会访问到对象的其他数据成员，而不仅仅是参数列表，这时候我们可能需要对外部数据也进行一个复制，这个过程非常困难，我们当然可以在需要的时候进行一个复制，对复制的声明当然可以聚集到一起，但依然会有第一个问题，即复制的开销，对于某些需要深度复制的，这个开销则更为离谱。因此实际上强烈保证是比较难提供的一个。（即用专业术语来讲应该是local data and non-local data）<br>
那么，我们实际上应该退而求其次，在无法做到强烈保证或因性能问题舍弃强烈保证的情况下，提供基本承诺。书上有一句我很喜欢，10年前的人们，认为异常安全是不需要关注的。（梦回10年前，实际上我之前的开发经验也不是特别关注异常安全，我们在出问题的时候更倾向于闪退，方便排除，而不是跳过这一段，因为catch就是为了不退出，如果不退出，则发现不了问题。

13. inlining函数的认知：以前可能未曾认识到的就是，所有包含对于virtual函数调用的inlining都会失败，从之前学习的csapp的知识可以知道，inlining在virtual之前执行，因此在virtual定位自己是哪个版本之前，inlining就已经需要virtual的实体了，(.o文件已经实体化inlining函数而.o之后的链接才会确认virtual？)
14. 将文件之间的编译依存关系降至最低，这条款主要讲了接口的优越性，虽然产生了额外的开销，但是接口能够满足降低编译依存的要求，且能够更好的隐藏实现细节，在java中接口本身是个关键字，但是CPP这边接口的实现方式分为多种，先说纯虚基类的方式，通过定义一个纯虚基类并且提供对应的create函数，继承纯虚基类的子类负责进行具体的实现，create函数负责根据具体情形创建具体的子类对象并返回纯虚基类的共享指针，这就形成了工厂模式，当然也可以在此基础上改成单例模式，但是没必要。第二种方法就比较有意思了，这种方法QT本身的底层代码已经采用了，前公司的通用性代码也多数都采用了这种方案，我们创建一个private类和普通的类，比如base和basePrivate，我们会把接口写在base里，而具体的实现细节来源是basePrivate。
15. 关于函数的作用域，我们之前可能注重的是，未重载的函数本身被覆盖了，即基类中f1()和f1(int x)在子类中如果有f1()则f1(int x)也不可见，对应的解决方法有using Base::f1;或者另一个规范：子类继承父类重载过的函数时，将所有同名重载函数全部继承（按需也行）。
16. 关于基类函数的声明和实现的继承方法：
<table>
<tr><th>pure virtual</th><th>强制子类实现，子类可以使用默认的实现方式</th></tr>
<tr><th>impure virtual</th><th>可能造成的问题是，子类想用，但是又没有声明的问题。（说是问题，其实子类写一遍声明就行）</th></tr>
<tr><th>non-virtual</th><th>不强制，子类可通过namespace访问父类方法</th></tr>
</table>

17.  绝对不要重新定义继承而来的non-virtual函数，考虑一个问题，我们通俗上会认为继承是符合，基类一般化，子类特化的这个概念，也就是说，假设A是基类B是子类，那么B一定是A的一种。这种被叫做is-a关系。现在有这样一种现象，假设A有一个non-virtual函数被B继承了，并且重写了。那么A和B在这个函数的定义上是不同地的，也就是说，B违背了B是A的一种这种概念，不符合is-a关系。
18.  绝不重新定义继承而来的缺省参数值，这条有个很有意思的现象，根本原因是因为缺省参数值是静态绑定，但是virtual函数是动态绑定，书中举例是以图形举例，例子中base class有缺省参数为red的函数成员，子类继承并重写其缺省参数值为green，在使用多态时，函数是动态绑定的，因此调用的是子类对象的函数，但缺省值是静态的，即是父类的red。解决方案是nvi，让父类的函数成员成为一个具有缺省参数的non-virtual函数，调用真正的private virtual接口。（接口声明和实现声明分开）
19.  谨慎地使用多重继承，多重继承在大多数情况下都可能出现二义性，除非使用虚继承加以限制，或者设计的时候小心地避免这个问题，使用虚继承会导致额外的开销，除非在base Class中不包含数据成员时，虚继承是解决多重继承二义性的最佳方案。当你需要public继承一个基类，但是同时也需要重写其他class的virtual函数时，多重继承是不可避免的。但大多数情况下，多重继承都有对应的单继承的方案。
20.  隐式接口和编译期多态，这两个玩意之前都算是没接触过，首先回忆一下显式接口，比如一个类，我们能够有其.h中的声明，有其.cpp中的实现，对于.h中的声明，它就是显式的，但对于一个template，他的声明多数是隐式的，它怎么声明取决于它需要什么，即使用中它调用了什么方法。对于tempalte参数而言，接口是隐式的，多态则是通过template具现化和函数重载发生于编译期。（很简单的理解，因为如果类型T不满足其隐式声明，编译器会报错，这是从结论反证理论。）
21.  typename的双重意义，一则是template\<typename T\>这种用来声明模板类型，另一种则是修饰嵌套从属名称。关于三种类型：1，从属名称指函数内出现的变量取决于template参数。2，嵌套从属名称则是在上述规则上进一步限定了访问方式，即使用类名称访问时属于嵌套从属名称，因为嵌套在类中，比如C::const_iterator。3，谓非从属名称（non-dependent names)，不依赖任何类型的名称。通常意义上，在嵌套从属名称的调用之前都应使用typename修饰，但在base class list即基类列表里不需要，以及member init list（构造函数后面那玩意）成员初始化列表中也不需要。
22.  使用member fuction templates生成可接受所有兼容类型的函数，如果声明的member template用于泛化copy或者泛化assignment,还是需要显式声明默认的copy和assignment。
23.  需要类型转换时请为模板定义非成员函数，这个在之前的所有类型皆需要类型转换时使用non-member function提到过，这里只是简单的提到了对应的模板版本出现的问题。这里的需求是，在通常版本的情况下，由于函数模板的类型推断方式和类模板不同，我们需要类模板的确定类型的推断方式而不需要函数的常规推断方式，这确定了我们需要将函数变成类模板的成员，但我们又根据条款24为了满足混合相乘的需求，因此使用non-menber，综合以上两点，我们这里应该选择友元。
24.  使用trait class表示类型信息，这个条款我暂时还没有理解透彻，不理解对于需求为什么要使用书中所示的代码框架。条款中目前对于我比较有用处的是，指明了if的判断会在运行期执行，而需求是在编译期执行这个判断。解决方案是使用重载去巧妙地将判断前移至编译期。这种满足了需求，但实际上确确实实也会增加.o文件的大小。
25.  TMP。template meta programming 是以CPP写成，执行于CPP编译器内的程序，一旦执行完，从template具现出的CPP代码，会像往常一样编译。书上特意提到一句，If this doesn’t strike you as just plain bizarre(奇异的), you’re not thinking about it hard enough.这句一开始我没有太看懂，后来得出来的结论是，众所周知C是由VB写的，java是由c或者cpp写的，通常上来讲，我们需要对某一个语言进行什么改变的话，需要使用的是其底层语言，但是按照TMP的概念，我们实际上是拥有了一个等效于底层语言的威力的功能。（底层？底层与编译器中间？）。关于TMP举的阶乘的例子确实比较有意思，通过定义结构模板，在内部调用n*n-1的值，通过对n=0时进行特化，使之结束阶乘（是的，一开始我认为这个不重要，就没写，后来编译器提示的是递归类型或函数依赖项上下文过于复杂。haha）。这个地方第二个特点是结构内使用了enum参与计算，这是一个很巧妙的点，因为用其他内置类型是无法在编译期进行计算的，因此在我的理解中这里只能使用enum。编译期进行替换的只有enum,define。使用define不满足需求。
26.  new_handler的行为，这一条款讲解了new是如何分配内存的， 通过set_new_handler可以设置分配内存时的错误处理函数。这一条款的重点在于new_handler的行为，因此下面我将开始记录其行为，后附模板形式的通用new_handler。<br>
* 调用标准的set_new_handler,告知widget的错误处理函数，这同时也会将widget的new_handler安装为global new_handler。(这样就拥有了global的内存分配权限)
*  调用global operator new ,执行实际的内存分配，分配失败则会调用global new_handler（此时已经被设置成了widget的new_handler）。假设global new operator new无法分配足够的内存，则会抛出一个bad_alloc异常，在这种情况下widget的operator new 必须恢复原来的new_handler再传播该异常（这个很好理解，没有见哪个分配失败了就无法使用的，即使没有分配空间，原先一般也是有个指向的）。global new_handler应该被视为资源运用资源管理对象进行管理。
* 如果global new_handler能够分配足够的空间，widget的operator new会返回一个指向这个分配空间的地址，代表这个空间可用。widget的析构函数负责管理global new-handler,目的是在析构之后将之前的global new-handler恢复。</br>
**怪异的循环模板模式(curiously recurring template pattern;CRTP)**-针对这一节的new-handler内容，如果我们希望widget能够拥有operate new和set new-handler，则需要继承一个NewHandlerSupport,但是为了让NewHandlerSupport支持所有的class，包括widget，所以NewHandlerSupport需要以模板形式写出。也就是说，一方面NewHandlerSupport需要传入widget作为模板参数，另一方面widget也需要继承它来获得这个权限。因此构成了一个怪异的循环模板模式。
27. 了解new和delete的合理替换时机，以及替换目的。先说替换目的，一般当我们需要替换new和delete的时候，会是以下三种情形：
* 用来检测运用上的错误,对于new分配所得的内存，做delete操作，如果delete操作失败，那么会导致内存泄漏，如果多次delete，则会导致不确定行为。（之所以说是不确定行为，是因为第一次delete之后，指针指向的地址很有可能是未知的，这也是我们基本不会看到代码中出现delete p;delete p;的原因。对于visual studio来讲，这个行为会在第二次delete的时候导致程序崩溃。）如果operator new持有一串动态分配所得地址，而operator delete将地址从中移走，则不会出现问题。（原因是，这个地方其实已经限制了内存的范围，即动态分配所得地址形成了一个地址区，删除的时候仅仅会从中删除，并且能够遍历地址区获得是否已删除的信息。）还可以检测一些运用上的错误，比如overruns-写入点在分配空间之后；或者underruns-写入点在分配空间之前；其实这两种也都可以用一个词来概括，无论是写入点过前还是过后，都可以称之为越界。如果是自定义的operator new,分配内存时我们可以额外分配固定大小的内存，在头尾分别做一个标记（标记一开始我考虑可不可能只有一位，后来想了一下一位是比较危险的，有可能出现虽然改了但是恰好改的和原先一致，其实会多一些空间比较好），operator delete就可以检查上述标记是否被更改，如果被更改，则可以确定对应的错误类型并log。
* 为了收集使用数据。书上这个地方的原因是从定制operator new和operator delete出发的，即在定制之前，你首先是需要知道这些东西干什么，怎么去干，所以需要收集包括如何使用动态内存，分配区块的大小分配，寿命分布，分配和归还次序（FIFO?LIFO?）,最大动态分配量，不同的执行阶段是否有不同的分配或归还形态（这个地方并不是通俗意义上的分配方式-堆分配或者栈分配什么的，而是指实际的内存分配方式，即分配的内存形态是连续的，抑或非连续的，或其他，这样解释起来就合理了）。从编译器的角度，收集这些信息是有助于用户进行错误调试的（考虑visual studio）。
* 为了增加分配和归还速度，这也是大部分时候需要重写cpp内置的一些东西的原因。（虽说是大部分时候的原因，但只有小部分情形需要重写，像小公司或者常见的情况，更多就是拿来就用。）举个例子，大多数编译器的内存管理器都是具有线程安全的功能的，但是假设你需要一个单线程分配器，从理论上来说自己定制一个operator new&delete确实是会比定制的要快。boost提供的pool程序库就是标准的内存管理器，但并不一定时时都满足你的需求。但这些的前提都是，你确认你的性能瓶颈是来源于内存函数。
* 为了降低缺省内存管理器带来的空间额外开销，如字面意思，但是前面提到的针对小型对象boost的pool程序库并不会产生这些额外的开销。（一开始我考虑了一下，这个内存是指内存管理器本身运行所需要的空间还是实际的内存地址的开销，后来想了一下这个问题本身没有意义，因为两者其实是一样的，如果实际的内存地址有额外的开销，在可视化操作系统的表现就是内存被占用了更多，再回到这条的空间额外开销本身，其实和前一条一样，缺省的总会考虑的更为全面，因此不仅会有速度上的开销，为了实现这种全面，空间上的开销肯定也是有的，这很好理解。）
* 为了弥补缺省分配器中的非最佳齐位，之前提到过，为了防止越界，我们可以额外分配一块内存用来记录边界，但是分配的这块内存并不总是齐位的，也就是说，定制的operator new&delete并不一直是齐位的，同样，缺省的并不一定也是齐位的（取决于你采用哪个缺省分配器）。举例来讲，如果doubles是8-byte齐位，理论上能够获得更高的速度，将缺省分配器替换为一个8-byte齐位版本会获得更好的性能。
* 为了将相关对象簇集中,将经常一起被使用的数据结构专门创建一个堆可以使之集中在尽可能少的内存页上，这样可以降低内存页错误的频率。
* 为了获取非传统的行为（我觉得这里虽然原文确实可以翻译成非传统的，但是这个地方可以认为是定制的功能），分配和归还共享内存能够实现的方式只有通过管理该内存的C API，编写一个自己的operator new&delete可以使之套壳为CPP版本。以及我们还可以通过自定义operator new&delete实现当我们释放某一块内存时，去将释放的内存赋值为0或自定义的数值，同样的，如果我们是对专用的类做operator new的操作，我们也可以通过自定义operator new去做一些初始化操作。
28. 编写new和delete需要固守常规。首先考虑new，实现一致性的operator new必须返回正确的指向分配内存的指针，在分配失败时调用正确的new-handler，必须有应对0内存需求的准备，必须能够避免掩盖正常形式的new（下一条条款会讲“正常形式的new”）。关于为什么把0byte需求当1byte看待，stackoverflow上的一个高分回答-在cpp中0内存的对象很常见，一般是后续需要运行时动态分配内存，因此需要能够分配0内存对象的操作，但实际上我们也需要有一个指针来指向，因此当作1byte。在operator new中，书上的伪码写出了一个循环，退出循环的方式只有内存被成功分配，或者调用了new-handling函数完成了自己的任务-让更多内存可用，安装另一个new-handler，卸除new-handler,抛出bad-alloc异常，或是承认失败直接return。Class专属版本应该处理比正确大小更大的错误申请（子类对象空间占用比父类大）。对于operator delete，保证传入null指针时不做任何动作，Class专属版本应该处理比正确大小更大的错误申请。
29. 写了placement new也应该写placement delete。 本节内容就如同标题一样，需要注意的标题是一点，还有一点是cpp默认给的三种operator new不能够被掩盖。如下：
```
void * operator new (std::size_t) throw (std::bad::alloc); //normal new
void * operator new (std::size_t, void *) throw(); //placement new
void * operator new (std::size_t,std::nothrow_t &); //能够保证operator new不抛出异常，但不能保证后续class的构造不异常，实际上没啥意义
```
30. 不要轻易忽视编译的警告。
31. 让自己熟悉包括TR1在内的标准程序库，这个我觉得可以分为两种情况来说，对于一个标准的CPP程序员来讲，确实是需要熟悉的，但是TR1之类的标准库可能不符合QT的跨平台要求，我认为如果是QT程序员，对于标准库的态度应该是作为模板去学习去模仿，而不是直接去用。CPP 98列入CPP的标准程序库：</br>
* STL，containers(such as vector、string、map、)、iterators、algorithms(such as find、sort、transform)、function objects(such as less,greater)、container adapters(such as stack,priority_queqe) and function object adapters(such as mem_fun、not1)。$\color{red}{(用英文的原因是这些常用，并且中文很难表达，这些之中我熟悉的基本只有container，其他都是需要补一补的。)}$
* IOSTREAM,覆盖用户自定义缓冲功能，国际化IO，预先定义好的对象cin,cout,cerr,clog。（海星）
* 国际化支持，主要是指对w_char以及unicode的支持，默认vs的编码是GBK文件，但是对于QT来讲，前公司强制要求unicode，包括QT中中文也需要用unicode字符。
* 数值处理，包括复数、纯数值数组(valarray);
* 异常阶层体系。包括 base class exception 和derived classes logic_error和runtime_error以及更深层次的class;
* C89标准库
</br>
接下来说TR1：
</br>
* 智能指针，包括share_pointer,weak_pointer,unique_pointer。
* tr1:function，可以表示任何callable entity。std::string func(int)只能是传入int返回string，但是std::tr1::function\<std::string (int)\>则可以接受任何形式传入int（比如隐式转换成int的参数），任何形式返回string的函数调用。
* tr1::bind (需要额外百度)
</br>
上述是tr1中通用的部分，其他的被分为两组，第一组：
* Hash Tables，以Hash方式重新实现了sets,multisets,maps和multi-maps。tr1::unordered_map等。
* 正则表达式
* Tuples, pair的新一代对象，pair本身只能有2个对象，但tuples可以有任意多个对象。
* tr1::array STL化的数组，大小固定，不使用动态内存。
* tr1::mem_fn,成员函数指针
* tr1::reference_wrapper，可以让reference行为更像对象，比如说，容器只能存对象和指针，但是通过这个，你可以容器存引用。
* 随机数工具：优于rand
* 数学特殊函数
* C99兼容扩充。
第二组tr的内容偏向于TMP编程:</br>
* Type traits,用以提供type的编译器信息，可以看到比如是否有viatural析构，是否可隐式转换成其他类型U等等。
* tr1::result_of,一个template,用来推导函数返回类型。在和数据库交互的时候会有这种需求，我们有时候并不知道不同数据库返回给我们的类型究竟是什么，之前很多时候都是对不同类型做了可能的猜测并且去判断，这个能够让类型推断更为简单。
