#  调度
## 批处理调度
###  先来先服务
  先来的立即进行处理，后来的排到队列中
###  最短作业优先
  先计算每个作业的时间，然后选最短的，这样会导致较长处理时间的作业会排到靠后，在极端情况下会导致长作业处理失败。（但是反言之，如果所有进程都会被调度，最短作业优先算法是最优的。）
###  最短剩余时间优先
  最短作业优先的抢占式版本，始终选择剩余时间最短的运行。
##  交互式操作系统的调度
### 轮询调度
  即读书时学的叫做时间片轮转的调度方式，但是其实翻译成轮询会更好，调度系统分配给每个进程一个时间片，时间片的时间执行完后立即切换，如果时间片内进程执行完了，会立即切换到下一个进程。
### 优先级调度
  调度系统根据重要性分配给每个进程一个优先级，根据优先级先执行。
### 多级队列
  多级队列应该算是时间片轮询的一个改进，根据优先级分为多级队列，每个队列的时间片分配不同，优先级越高的分配的时间片越少。（想一下为什么是最少而不是最多？）
### 最短进程优先
  此调度算法根据进程的过去行为进行预测，去估计运行时间最短的一个，
### 保证调度
  对用户做出明确的性能保证是一种完全不同的调度方法，一种实际而简单容易实现的保证:对于n个用户，每个用户得到的时间片是1/n，对于n个进程，每个进程得到的是1/n，那么对于n个用户的n个进程中的某一个，得到的调度会是1/n<sup>2</sup>。
### 彩票调度
  为进程提供**各种系统资源**的彩票，当做出一个调度抉择时，随机抽出一张彩票，拥有彩票的进程将获得该资源，在应用到CPU调度时，系统可以每秒持有50次抽奖，每个中奖者将获得比如20MS的CPU时间作为奖励
### 公平分享调度
  目前考虑到的调度算法都是以进程为单位，并不考虑其拥有者，但是这样对于用户其实不一定公平，用户A拥有9个进程，用户B拥有1个进程，那么用户A拿到的时间片则会是9/10，而B拿到1/10。有些操作系统考虑到这种情况，则会给A,B相同的CPU时间，再由具体的进程数分配。
## 实时系统的调度
  实时系统分为硬实时和软实时。硬实时要满足绝对的截止时间，软实时则是虽然不希望偶尔错失截止时间，但是可以容忍。实时系统按照响应方式可以分为周期性和非周期性，一个系统可能要响应多个周期性事件流，如果有m个周期事件，事件i以周期Pi发生，并需要Ci秒CPU时间处理一个事件。那么可以处理负载的条件是：$$\sum_{i=1}^{m} {\frac {Ci} {Pi}} \leq 1$$
#  页面置换算法
## 最优页面置换算法
最优页面置换算法的理论基础是每一个页面都知道什么时候会轮到它，比如各个页面都知道，A:1,B:2,C:3,ABC三个页面清晰地知道自己在多少个页面之后才会被调用，这个时候我们就会置换C，因为C最晚被用到，推迟了缺页中断。但实际上在缺页中断发生时，页面并不知道还有前面有多少个页面在排队，因此此算法虽最优，但无法实现。
## 最近未使用页面置换算法
  首先有一个页表项的概念图：
  <table border=1px><tr><td>&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp</td><td>高速缓存禁止位</td><td>访问位</td><td>修改位</td><td>保护位</td><td>在/不在位</td><td>页框号</td></table>
  在这个概念图的基础下，为了能够让操作系统收集信息，大部分使用虚拟内存的系统都有2个状态位，R和M，每当引用页面时都设置R，写入页面时设置M，引用包括写入和读。这些位一般是由硬件进行控制。用R和M位构造一个简单的页面置换算法如下：当一个进程被启动时，其对应的RM位都置0，R在每个时钟周期定期归0，用来将最近未引用和最近引用的页面分开。，根据RM的值，页面可分为4类。


  - 第0类：没有引用R，没有修改M
  - 第1类：没有引用R，已修改M
  - 第2类：引用R，没有修改M
  - 第3类：引用R，已修改M
  当第3类的R位被时钟中断清零R位时，就会产生第1类。NRU（not recently used）算法从编号最小的非空类中随机删除一个页面，在一个时钟内淘汰一个已修改但是没有访问的页面比一个大量引用未修改的页面好，NRU的优点是易于理解并实现。
## 先进先出的页面置换算法
FIFO算法，移除头部并把新的页添加到尾部。
## 第二次机会页面置换算法
此算法算是FIFO的改进，对于FIFO，当旧的页面即将被删除时，去判断其R位，如果R位为0，则会被淘汰出内存，或写回磁盘，或简单地放弃，如果R位为1，则将这个页面放到链表尾部并设置其装入时间为当前时间，然后清除R位。然后从头部开始搜索合适页面。
## 时钟页面置换算法
想象一个表盘，分为了12份，每一个时刻必定会指向一个hour,指向的位置代表一个页面，发生缺页中断时，如果对应的位置R位为0，则置换新页面进来，如果R为1，则清除R位，并向前移动表针。
## 最近最少使用置换算法
在发生缺页中断时，置换最近最少使用的页面，即LRU，LRU的实现难处在于，为了完全实现，需要在系统里维护一张包含所有页面的链表，最频繁使用的页面位于表头，最近最少使用的页面位于表尾，在每次引用时更新整个链表是一件比较困难的事情，因为整个链表几乎都要移动，在链表中找到一个页面并删除，然后把它移动到表头，即使用硬件实现也是比较耗时的。
## 最不常用算法（NRU）
使用一个软件计数器和每个页面关联，初始化的时候为0，在每个时钟中断时，操作系统浏览内存的所有页，将每个页面的R位加到计数器上，这个计数器大体上跟踪了各个页面访问的频繁程度，当缺页中断出现时，置换计数器最小的页面。
对NRU做一个简单的修改使之变为老化算法:

-首先，在R位被添加进来之前先把计数器右移一位
-第二，R位被添加到最左边的位而不是最右边。
具体的图可以参照这个网址：https://www.cnblogs.com/cxuanBlog/p/13297199.html
## 工作集时钟算法
替换的数据结构是一个以页框为元素的循环列表。

# 文件
## 文件系统布局
这个地方不从操作系统的角度来看文件系统，而是从使用者的角度来看文件系统。大多数磁盘可以划分出多个分区，其中一般0号分区被称之为主引导记录(master boot record)，用来引导计算机，在MBR的结尾是分区表。分区表记录了每个分区从开始到结束的地址。当计算机开始引用boot时，BIOS读入并执行MBR。
### 引导块
MBR首先需要确定活动分区，读入其第一个块，称之为引导块。引导块中的程序会加载分区中的操作系统，为了保持一致，每个分区都会从引导块开始，即使此分区不包含操作系统，引导块占用文件系统的前4096个字节，从磁盘上偏移量为0的位置开始。
  <table border=1px><caption>磁盘分区</caption><tr><td>引导块</td><td>超级块</td><td>空闲空间管理</td><td>inode</td><td>根目录</td><td>文件和目录</td></table>

### 超级块
超级块的大小为4096字节，但是起始位置为4096。超级块包含文件系统的关键参数：文件系统的大小、文件系统的数据块数、指示文件系统状态的标志、分配组大小。
### 空闲空间块
空闲空间块在CSAPP对应的就是free node，free node组成free list 即会被细分为的显式空闲链表和隐式空闲链表。
### 碎片
碎片，也叫片段，是在驱动器上不相连的文件片段。
### inode
索引节点，是一个数组的结构，包含了文件的基本信息，存储对象的数据和磁盘块位置。
## 文件的实现
文件实现的主要问题就是各个文件分别用到了哪个磁盘块。分配方法背后的思想或目的：有效利用空间和快速访问文件。主要有三种分配方案：

- 连续分配
- 链表分配
- 索引分配
### 连续分配
连续分配如名字所说，即文件和文件之间就块的单位，是相连的，假设一个块是50KB，如果有文件只占了3/2块。那么确实会空出来半块，从这个意义上就不相连了，但是就块的单位来讲，是相连的。优点：1、实现简单，只需要记住2个数字，一个是第一个块的文件地址，另一个是文件的块数量，可以通过加法找到其他快。2、读取性能强，可以只用一次读取获取文件，不需要额外的寻道时间和旋转延迟，所以数据是以全带宽进入磁盘。 缺点：会产生碎片。
### 链表分配
同样如名字一样，将文件块以链表的形式链接，不会浪费空间，但是因为链表结构本身的缺点，导致这种方式分配会使随机访问变得困难，因为链表结构本身就有这个缺点。还有就是指针本身占空间，512GB需要减去指针的空间才会是实际可以使用的空间。
### 使用内存表进行链表分配
详情可见CSAPP中的文件表，本身不是算难的结构。
## 目录的实现
文件本身需要打开之后才能读取，目录的作用就是供操作系统获取读取文件的必要信息，这个过程也可以描述为，将文件的ascii码的名称映射到定位数据所需要的信息上。
### 共享文件
目录结构如果在不存在共享的情况时，可以简单的认为是一棵树，但是当用户之间有共享的文件时，图即转化为有向无环图（DAG），C的文件出现在B的目录下，称之为链接（link）。
### 日志结构文件系统
出现日志结构文件系统的原因：CPU的性能越来越强，磁盘容量越来越大，但是磁盘的寻道时间并没有提高。因此本系统出现，旨在解决以下问题：

- 不断增长的系统内存
- 顺序IO性能胜过随机IO
- 现有的低效率文件系统
- 文件系统不支持RAID（虚拟化）

当时的系统有大量的随机读写，成为了整个系统的性能瓶颈，但是因为Page cache的存在，CSAPP也讲过，大大提高了随机读的效率，大部分的读操作都能够被cache，但是写不能。    基于这种出发点，iNode的结构并没有发生变化，但是现在iNode分散在整个日志中，而不是磁盘上的固定位置，为了找到iNode，维护了一个在内存和磁盘都有副本的iNode map（iNode 映射）。到这一步，所有的写入最初都缓存在内存，并追加到日志尾，所有缓存的写入都定期在单个段中写入磁盘。所以，现在打开文件的流程变成了，找到映射定位文件的索引节点，iNode被定位后万事大吉。真实情况下磁盘容量是有限的，如果日志占满了整个磁盘空间，这种情况下就会存在没有新的块写入到日志，如果一个文件被覆盖了，它的iNode可能已经指向了新的块，但是旧的磁盘块仍然在先前写入的段中占据空间。为了解决这个问题，LFS会有一个清理线程，这个线程循环日志，检查iNode的map查看是否仍在当前块中，是否仍在使用，如果不是，该信息被丢弃，如果使用，将iNode和块进入内存等待写回下一个段，原来的段标记为空闲。
### 日志文件系统
从日志结构文件系统衍生出一种日志文件系统，它会记录系统下一步要做什么的日志。微软的NTFS，linux的ext3都采用了此日志。假设一个移除文件操作，这个操作在UNIX中需要三步：

- 在目录中删除文件
- 释放iNode到空闲iNode池
- 释放磁盘块到空闲磁盘池

### 虚拟文件系统
详情参照CSAPP。讲的比较详细，大致需要记住一点就是，通过虚拟文件系统，所有的存储设备被虚拟成了一个大的字节数组。

## 文件系统的管理和优化
### 磁盘空间管理
从文件的层级上存取有两种方案，即分配n个字节的连续磁盘空间，或者把文件拆分成多个但是不一定连续的块。从存储系统的层级上有分页管理和分段管理。按字节连续存储的问题在于移动文件时的性能太差，但内存中段的移动效率快很多，因此采用分块并在内存中处理，是可以接受的。
### 块大小
合适即可。
### 记录空闲块
#### 磁盘块链表
显式空闲链表和隐式空闲链表
#### 位图
n个块的磁盘需要n位位图，简单来说，一个块对应一个01，只有当磁盘快满时，链表需要的块才会比位图少。
## 磁盘配额
<table>
<caption>配额表</caption>
<tr><td>软块限制</td></tr>
<tr><td>硬块限制</td></tr>
<tr><td>块的当前编号</td></tr>
<tr><td>剩余块数通知</td></tr>
<tr><td>软文件限制</td></tr>
<tr><td>硬文件限制</td></tr>
<tr><td>文件当前的编号</td></tr>
<tr><td>剩余文件数通知</td></tr>
</table>
为了防止一些多用户系统其中某个用户占有过多的磁盘空间，多用户操作系统通常提供一个叫做用户配额的机制来限制其磁盘空间。用户打开一个文件时，操作系统会找到对应的文件属性和磁盘地址，并送入打开文件表，通过打开文件表的属性，去找对应的配额表，根据配额确认是否可以分配空间，或者分配哪块空间。用户可以超出软限制，但不能超出硬限制。

## 文件系统备份
### 增量转储
最基础的增量转储就是周期性地做全面备份，每天只对跟上一次备份不同的地方做单个备份。但是这个流程恢复起来比较麻烦，因为需要先全面恢复，然后再逆序做修改的恢复。转储的往往是海量数据，那么就需要压缩，但是如果备份过程中出现文件损坏，就会破坏压缩算法，导致整个文件无法读取。以及对于正在使用的文件系统，做增量转储是很难的，（脏读问题），但是由于转储过程时间比较长，因此需要放在晚上进行几个小时的备份，这是不能接受的，因此修改转储算法，为，记录下文件系统的瞬时快照，即复制关键数据结构，然后需要把将来对文件和目录的修改复制到块中。

磁盘备份到磁盘上有两种方案，物理转储和逻辑转储，物理转储即字面意思，一块复制到另一块，

## 文件系统的一致性
即解决文件脏读问题（比如开文件，然后磁盘G了，这个时候文件和磁盘是不一致的）。

# 资源和死锁
## 临界区的概念
临界区并不是具体的某一个变量，而是某一条或多条读写访问的语句。多线程同时读可能会导致脏读，这种一般只会导致逻辑错误，多线程同时写则可能导致崩溃
## 资源
大部分死锁都和资源有关，在进程对设备，文件具有独占性时会产生死锁。这种排他的对象，叫做资源，资源分为可抢占资源和不可抢占资源。可抢占资源，可以从拥有它的进程而不会造成其他影响，不可抢占资源(nonpreemtable resource)指的是除非引起错误或者异常，不然进程无法抢占资源，比如光盘，(想想是否有其他例子)。
## 死锁
死锁：一组进程中的每一个进程都在等待一个事件，而这个事件只能由这组进程中的某一个事件触发。
资源死锁的条件：
- 互斥条件：每个资源都被分配给了一个进程或者是可用的
- 保持和等待条件：已经获取资源的进程被认为能够获取新的资源
- 不可抢占条件：分配给一个进程的资源不能强制地从其他进程抢占资源，只能由占有它的进程显式释放。
- 循环等待:死锁发生时，一定有一组进程能够组成循环，每个进程都在等待下一个进程释放资源。
## 死锁的处理策略
- 忽略死锁带来的影响，(鸵鸟)。。。。。。。
- 检测并恢复死锁
- 通过仔细分配资源避免死锁
- 通过破坏死锁产生的四个条件之一来避免死锁

## 死锁的检测和恢复
### 资源分配表
资源分配表的构建可以见前面的网址，大概意思就是，构造一个创建和释放的流图，如果其中有环，则死锁。
### 每种类型多个资源的死锁检测方式
假设资源类型为m，E1代表资源类型1，E2代表资源类型2，Ei代表资源类型i，那么可以构造出一个向量E=(E1,E2,E3···E<sub>n</sub>)，代表每种已存在的资源总数的集合。现在需要构造2个数组，C表示当前分配矩阵，R表示请求矩阵。Ci表示的是Pi持有的每一种类型资源的资源数。所以C<sub>ij</sub>表示Pi持有的资源j的数量。R<sub>ij</sub>表示Pi所需要的资源j的数量。可以获得的一个等式是：已分配资源j的数量+可供分配的资源数量=该类资源的总量。
### 从死锁中恢复
#### 通过抢占恢复
将某个临时资源从它的持有者转到另一个进程，不通知原进程，强取后再送回，但难以实现并且粗暴不可取。
#### 通过回滚恢复
创建监测点，检测点包含存储映像和资源状态，把所有的检测点按照日志的格式累计起来，一旦发生死锁，可以回滚到上一个没有死锁的检测点。
#### 杀死进程恢复
最简单的方案就是杀死一个死锁进程，这样就破坏了环，解决了死锁问题，但有时候单独杀死一个可能不能解决问题，另一种方式是选择一个环外的进程作为牺牲品来释放进程资源。

## 死锁的避免
### 单个资源的银行家算法
具体不详细介绍，经典算法。
### 破坏死锁
死锁本质上其实是无法避免的，因为需要获取未知的资源和请求。但出现死锁后一定会满足4个条件：

- 互斥
- 保持和等待
- 不可抢占
- 循环等待

### 破坏互斥条件
如果一个资源不被一个进程独占，那么死锁就不会产生，例如打印机的解决方案是采用了假脱机打印机，这样就可以多个进程同时使用一个打印机进行输出，解决了死锁的问题。
### 破坏保持等待条件
如果我们能阻止持有资源的进程请求其他资源，我们也能够解决死锁，一种实现方式是进程开始执行前，先请求所需要的全部资源，但凡有资源不可分配，进程就被挂起等待，但是很多进程执行时无法知道具体需要多少资源，如果知道，就可以使用银行家算法，但是这样依然还是存在无法合理有效利用资源的问题。还有一种方式是，进程在请求其他资源时，先释放所占用的资源，然后请求所有的资源。这样就不会存在拥有资源的进程请求其他资源的情况。
### 破坏不可抢占条件
可以通过虚拟化的方式实现
### 破坏循环等待条件
一种方式是制定一个标准，一个进程在任何时候只能使用一种资源，如果需要另一种资源，必须释放当前资源，但是对于大文件从磁盘复制到打印机的过程，这个是无法接受的。另一种方式是将资源编号。进程可以在任何时间提出请求，但是一定要按照资源顺序来。

## 其他问题
### 两阶段加锁
一个场景是数据库中部分操作会请求锁住一些记录，然后更新所有锁住的记录，当同时有多个进程执行时，就可能出现死锁。两阶段提交的方式可以解决这个问题，一阶段尝试一次锁定所有需要的记录，二阶段执行更新并释放锁。类似于先检测然后判断是否执行。
### 通信死锁
资源死锁只是死锁的一种类型，也存在通信死锁的情况。A发给B消息，消息丢失，A会等待B响应，B会等待A发送，于是G了。通信死锁可以通过超时重新发送的方法来解决。
### 活锁
场景：你和对面互相让路，都左右让卡住嘞。
### 饥饿
假设打印机的分配方案是优先小的，那大文件就会一直GG，进程很长一段时间就不会获取资源G!!!!!!!!!